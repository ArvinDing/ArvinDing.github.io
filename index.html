<h4 id=screen>Screen Coordinates:</h4>
<h4 id=screen1>Transformed Coordinates:</h4>

<canvas id="canvas" width="1200" height="600"></canvas>

<script>
    const canvas = document.getElementById("canvas");
    let ctx = canvas.getContext("2d");
    class node {
        constructor(val, x, y) {
            this.value = val;
            this.x = x, this.y = y;
            this.left = null;
            this.right = null;
        }
        display() {
         
            

            if (this.right){
                ctx.beginPath();
                ctx.moveTo(this.x,this.y);
                ctx.lineTo(this.right.x, this.right.y);
                ctx.stroke();
              this.right.display();
            }
            if (this.left){
                ctx.beginPath();
                ctx.moveTo(this.x,this.y);
                ctx.lineTo(this.left.x, this.left.y);
                ctx.stroke();
                this.left.display();
            }
            fillCirc("black", this.x, this.y, 20);
            fillCirc("white",this.x,this.y,18);
            drawText(this.value,this.x-5,this.y+6,18,'arial');
        }
    }
     tree = new node(Math.floor(10*Math.random()), 80, 100);
     tree.left= new node(Math.floor(10*Math.random()),10,150);
     tree.left.left= new node(Math.floor(10*Math.random()),10-40,200);
     tree.left.right= new node(Math.floor(10*Math.random()),10+40,200);

     tree.right= new node(Math.floor(10*Math.random()),150,150);
     tree.right.right= new node(Math.floor(10*Math.random()),190,200);
     tree.right.left= new node(Math.floor(10*Math.random()),110,200);

    const pi = Math.PI;
    const width = 1200;
    const height = 600;
    const zoomIntensity = 0.1;
    let panX = 0, panY = 0, mouseD = false;
    let scale = 1;
    canvas.onwheel = function (event) {
        event.preventDefault();
        const mX = event.clientX - canvas.offsetLeft;
        const mY = event.clientY - canvas.offsetTop;
        const wheel = event.deltaY < 0 ? 1 : -1;
        const zoom = Math.exp(wheel * zoomIntensity);
        rX = (mX - panX) / scale, rY = (mY - panY) / scale;
        panX = mX - (scale * zoom) * rX;
        panY = mY - (scale * zoom) * rY;

        scale *= zoom;
    }

    function update(timestamp) {
        ctx.clearRect(0, 0, width, height);
        ctx.save();
        //scale bigger, zoomed in   
        ctx.translate(panX, panY);
        ctx.scale(scale, scale);
        //xtrans=(xscreen- panX)/scale
        tree.display();

        //transformed coordinates, coordinates in the background

        ctx.restore();
        window.requestAnimationFrame(update);
    }
    update();

    function fillRect(color, sx, sy, w, h) {
        ctx.fillStyle = color
        ctx.fillRect(sx, sy, w, h)
    }
    function drawText(text, x, y, fontSize, fontF) {
        ctx.fillStyle = "black";
        ctx.font = fontSize + "px " + fontF;
        ctx.fillText(text, x, y);
    }

    function fillCirc(color, x, y, r) {
        ctx.beginPath()
        ctx.arc(x, y, r, 0, 2 * pi)
        ctx.fillStyle = color
        ctx.fill()
    }
    start = {};
    canvas.addEventListener("mousedown", function (evt) {
        let mX = event.clientX - canvas.offsetLeft;
        let mY = event.clientY - canvas.offsetTop;
        rX = (mX - panX) / scale, rY = (mY - panY) / scale;
        document.getElementById("screen").innerHTML = ("Screen Coordinates: " + mX + "/" + mY);
        document.getElementById("screen1").innerHTML = ("Screen Coordinates: " + rX + "/" + rY);

        mouseD = true;
        start = { x: rX, y: rY };
    });

    canvas.addEventListener("mousemove", function (evt) {
        let mX = event.clientX - canvas.offsetLeft;
        let mY = event.clientY - canvas.offsetTop;
        rX = (mX - panX) / scale, rY = (mY - panY) / scale;
        if (mouseD) {
            panX += (rX - start.x);
            panY += (rY - start.y);
        }
    });

    canvas.addEventListener("mouseup", function (evt) {
        mouseD = false;
    });
</script>